<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-铜板切金条" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/18/%E9%93%9C%E6%9D%BF%E5%88%87%E9%87%91%E6%9D%A1/" class="article-date">
  <time class="dt-published" datetime="2020-01-18T01:30:03.000Z" itemprop="datePublished">2020-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/18/%E9%93%9C%E6%9D%BF%E5%88%87%E9%87%91%E6%9D%A1/">铜板切金条</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="F:/blogPic/image-20200118093232022.png" alt="image-20200118093232022"></p>
<p>切得过程中未必要挨着。吧  </p>
<p>如果一个数组：[1,4,2,3,5],</p>
<p>你也可以先切1和5.</p>
<p>做法：先切出一个9（4+2+3）和6（1+5）</p>
<p>然后把6切成1+5</p>
<p>所以说，你只要切出这些部分就可以了</p>
<p><strong>这是一个标准的哈夫曼编码问题</strong></p>
<p><strong>子节点合并在一起的代价是加起来的和</strong></p>
<p>就是把所有的叶子节点加起来生成一颗树</p>
<img src="F:/blogPic/image-20200118094902220.png" alt="image-20200118094902220" style="zoom:50%;" />

<p>把这个数组放到小根堆里</p>
<p>[1,2,6,4,3,7,1,8]</p>
<p>拿出两个数 ：肯定是那两个1，把他俩合并，产生一个2，<strong>代价是2</strong></p>
<p>然后把这个2仍回到小根堆里面</p>
<p>数组变成：[2,6,4,3,7,8,2]</p>
<p>再拿出两个最小的，是两个2，把他俩合并，产生一个4，<strong>代价是4</strong></p>
<p>然后把4仍回到小根堆里</p>
<p>数组变成：[6,3,7,8,4,4]</p>
<p>在拿出两个最小的，4 和3 ，把他俩合并，产生一个7，<strong>代价是7</strong></p>
<p>数组变成[6,7,8,7,4]</p>
<p>在拿出两个最小的，4 和6 ，把他俩合并，产生一个10，<strong>代价是10</strong></p>
<p>数组变成[10,8,7,7]</p>
<p>在拿出两个最小的，7和7 ，把他俩合并，产生一个14，<strong>代价是14</strong></p>
<p>数组变成[10,8,14]</p>
<p>在拿出两个最小的，8和14，把他俩合并，产生一个22，<strong>代价是22</strong></p>
<p>数组变成[10,22]</p>
<p>在拿出两个最小的，10和22，把他俩合并，产生一个32，<strong>代价是32</strong></p>
<p>数组变成[32]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lessMoney</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		PriorityQueue&lt;Integer&gt; pQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			pQ.add(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (pQ.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			cur = pQ.poll() + pQ.poll();</span><br><span class="line">			sum += cur;</span><br><span class="line">			pQ.add(cur);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>一个花费数组和一个利润数组，表示一个是这个项目的花费，一个是这个项目的利润，</p>
<p>然后给你一个初始资金W，并且每次只能做一个项目 ，你如果最多做K个项目的情况下，</p>
<p>都做完，或者是做不下去了的时候，停</p>
<p>问最终你的钱剩下多少。</p>
<img src="F:/blogPic/image-20200118162207256.png" alt="image-20200118162207256" style="zoom: 67%;" />

<p>第一步：生成每一个项目</p>
<p>第二部：准备一个小根堆，谁花费低，谁在头部，把项目都放进去</p>
<p>然后看初始资金。</p>
<p>在小根堆里面依次弹出头部，只要比W初始资金小的都弹出来，</p>
<p>弹出来之后放到一个大根堆里面，是根据收益高组成的大根堆</p>
<p><strong>小根堆里放的是所有的项目，而大根堆里放的是所有解锁的项目</strong></p>
<p>从大根堆里面弹出一个项目来，这个项目一定是所有解锁的项目中收益最高的，</p>
<p>做完这个项目后，初始资金就会增加，</p>
<p>然后我在看看新的初始资金能不能解锁一个新的项目</p>
<p>把解锁的新的项目在扔到大根堆里面去</p>
<p>大根堆里面在选一个利益最大的项目做</p>
<p>这样来回，一直做K个 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每个项目就是一个点，p是利润，c花费</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">int</span> p;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.p = p;</span><br><span class="line">			<span class="keyword">this</span>.c = c;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是花费低的比较器，谁花费低，谁放上面</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MinCostComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">        </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> o1.c - o2.c;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//这是收益的比较器，谁收益高，谁放上面</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxProfitComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> o2.p - o1.p;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//K是做多少个项目，W是总共有多少钱</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMaximizedCapital</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> W, <span class="keyword">int</span>[] Profits, <span class="keyword">int</span>[] Capital)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//形成节点（项目）</span></span><br><span class="line">		Node[] nodes = <span class="keyword">new</span> Node[Profits.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Profits.length; i++) &#123;</span><br><span class="line">			nodes[i] = <span class="keyword">new</span> Node(Profits[i], Capital[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//准备一个花费的小根堆，谁小谁放上面</span></span><br><span class="line">		PriorityQueue&lt;Node&gt; minCostQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> MinCostComparator());</span><br><span class="line">        <span class="comment">//准备一个利润的大根堆，谁大谁在上面</span></span><br><span class="line">		PriorityQueue&lt;Node&gt; maxProfitQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> MaxProfitComparator());</span><br><span class="line">        <span class="comment">//把所有的项目，加到小根堆里面去</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">			minCostQ.add(nodes[i]);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//我要依次左项目了</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">//所有被解锁的项目，你们都到利润谁大谁在上面的大根堆去</span></span><br><span class="line">			<span class="keyword">while</span> (!minCostQ.isEmpty() &amp;&amp; minCostQ.peek().c &lt;= W)&#123; <span class="comment">//如果花费最少的那个项目小于总的钱</span></span><br><span class="line">                <span class="comment">//那么该项目弹出来，放到大根堆中</span></span><br><span class="line">                maxProfitQ.add(minCostQ.poll());</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//如果大根堆空了，说明没有项目可以做了，不得不停</span></span><br><span class="line">			<span class="keyword">if</span> (maxProfitQ.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">return</span> W;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//我做了一个利润最大的项目，然后本金+利润</span></span><br><span class="line">			W += maxProfitQ.poll().p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> W;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="宣讲会例子"><a href="#宣讲会例子" class="headerlink" title="宣讲会例子"></a>宣讲会例子</h2><p><img src="F:/blogPic/image-20200118172622253.png" alt="image-20200118172622253"></p>
<p>贪心策略：按照结束时间来排序，然后淘汰掉因为做这个项目做不了的项目</p>
<img src="F:/blogPic/image-20200118173208434.png" alt="image-20200118173208434" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是宣讲会	</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> start;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Program</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.start = start;</span><br><span class="line">			<span class="keyword">this</span>.end = end;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//按照谁先结束谁在前的比较器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgramComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Program</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Program o1, Program o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> o1.end - o2.end;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bestArrange</span><span class="params">(Program[] programs, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">		Arrays.sort(programs, <span class="keyword">new</span> ProgramComparator());</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; programs.length; i++) &#123;</span><br><span class="line">            <span class="comment">//如果这个项目时刻是比当前时刻大的话，可以安排</span></span><br><span class="line">			<span class="keyword">if</span> (cur &lt;= programs[i].start) &#123;</span><br><span class="line">				result++;</span><br><span class="line">                <span class="comment">//当前时刻就来到的项目的结束时刻了</span></span><br><span class="line">				cur = programs[i].end;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/18/%E9%93%9C%E6%9D%BF%E5%88%87%E9%87%91%E6%9D%A1/" data-id="ckn4703xq005p0svha1cz2vq9" data-title="铜板切金条" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-贪心" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/18/%E8%B4%AA%E5%BF%83/" class="article-date">
  <time class="dt-published" datetime="2020-01-18T00:15:26.000Z" itemprop="datePublished">2020-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/18/%E8%B4%AA%E5%BF%83/">贪心</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="什么是字典序？"><a href="#什么是字典序？" class="headerlink" title="什么是字典序？"></a>什么是字典序？</h3><p>就是在字典中出现的次数。</p>
<p>比如“abc” 在“c”前面出现</p>
<p>严格来讲，a-z的字符就是26个数字，当长度一样的时候，就是字面值的比较</p>
<p>比如说“abc” 和“bce”哪一个字典序小啊？</p>
<p> abc和bce表示3位都是26进制的数，那么abc较小</p>
<p>长度不等的时候？比如“abc”，“b”</p>
<p>此时把短的东西后面补上ascll码值为0的东西，让他变成长度为3的</p>
<p>‘abc’ 和‘b00’比较</p>
<p>abc较小，因为最高位的b要比a大，</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有一个字符串数组，请你拼接字符串，</p>
<p>比如’’ab”,”cd”,”ef”   请你拼接成字典序最小的那种方式，</p>
<p>结果是abcdef</p>
<p>可以按照字符串的序列排好然后拼接么？</p>
<p>不行，比如：</p>
<img src="F:/blogPic/image-20200118084218288.png" alt="image-20200118084218288" style="zoom:33%;" />

<p>bba不是最小的，bab才是最小的，所以不能这样干。<br>所以排序策略：</p>
<img src="F:/blogPic/image-20200118084637992.png" alt="image-20200118084637992" style="zoom:50%;" />

<p>第二种是对的</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (a + b).compareTo(b + a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">lowestString</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//按照我的排序规则排序</span></span><br><span class="line">		Arrays.sort(strs, <span class="keyword">new</span> MyComparator());</span><br><span class="line">		String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">			res += strs[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





<h2 id="什么是贪心？"><a href="#什么是贪心？" class="headerlink" title="什么是贪心？"></a>什么是贪心？</h2><p><strong>给你一个指标，每一个样本分出一个优先来</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/18/%E8%B4%AA%E5%BF%83/" data-id="ckn4703xh00570svh3me426e6" data-title="贪心" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-基础笔试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/17/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2020-01-17T07:03:24.000Z" itemprop="datePublished">2020-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/17/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AF%95%E9%A2%98/">基础笔试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h2><ol>
<li>封装：隐藏对象的属性和实现细节，仅仅对外提供公共的访问接口。</li>
<li>继承：继承是从已有类得到继承信息创建类的过程。提供信息的是父类，得到信息的是子类</li>
<li>多态：一个类的多种形态，就是用同一个对象调用同一个方法得到的结果不同。<ul>
<li>编译器多态：方法重载</li>
<li>运行时多态：方法重写 ，子类重写了父类的方法，则该方法指向子类，子类没有重写父类的方法，该方法会向上寻找，指向父类</li>
</ul>
</li>
<li>抽象：就是把现实生活中的对象抽象成类，对象的行为作为类的方法，对象的属性，作为类的属性</li>
</ol>
<h2 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h2><table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protect</th>
<th>default</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>本类</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
</tr>
<tr>
<td>本类，本包</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
<td></td>
</tr>
<tr>
<td>本类，本包，父子类</td>
<td>ok</td>
<td>ok</td>
<td></td>
<td></td>
</tr>
<tr>
<td>所以</td>
<td>ok</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="基本数据类型有哪些"><a href="#基本数据类型有哪些" class="headerlink" title="基本数据类型有哪些?"></a>基本数据类型有哪些?</h2><p>基本数据类型：byte short int long float double char boolean<br>引用数据类型：数组，接口，类 </p>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ol>
<li>char 能转成int int 不能转成char</li>
<li>整形的（byte short int long ）可以自动类型转换成浮点型的（float，double）<br>如果同是整型或是浮点型的话，站位少的可以自动转换为占位多的</li>
<li>short byte 在进行运算时先转成整型，在运算，所以结果是整型。 +=符号可以自动类型转换<br>自增，自减运算符<br>i=1;<br>i=i++;<br>结果是1；</li>
</ol>
<h2 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f=3.4;是否正确"></a>float f=3.4;是否正确</h2><p>不对，3.4默认是double 类型，而double类型不能自动类型转换为float类型 因该是3.4f</p>
<h2 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？"></a>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</h2><p>前面的有错，short类型参加运算时都要转换成int类型进行运算，所以右边最后是int类型，而左边是short类型，short类型不能自动类型转换为int类型</p>
<p>后面的没错，因为扩展赋值运算符强制转换</p>
<h2 id="switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上"><a href="#switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上" class="headerlink" title="switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上"></a>switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上</h2><p>byte short int char  java7后支持String</p>
<h2 id="Thread类的sleep和wait-的区别"><a href="#Thread类的sleep和wait-的区别" class="headerlink" title="Thread类的sleep和wait 的区别"></a>Thread类的sleep和wait 的区别</h2><p> <strong>sleep()方法</strong>正在执行的线程主动让出CPU（然后CPU就可以去执行其他任务），在sleep指定时间后CPU再回到该线程继续往下执行(注意：sleep方法只让出了CPU，而并不会释放同步资源锁！！！) </p>
<p>wait方法,当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了该对象的notify()方法，之前调用wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行。 </p>
<p>sleep 方法 是 线程类Thread的静态方法，使线程暂停指定的时间 ，把CPU让出来，然后cpu去执行其他任务，时间到后，该线程进入就绪状态，抢到CPU后继续执行该线程 ,并不会释放同步资源锁<br>wait 方法 是 Object类的方法，使线程退出同步资源锁，进入到等待队列，以便其他正在等待该资源的线程得到该资源，调用notify/notifyAll 唤醒指定线程或者所有线程，进入到就绪状态，然后抢cpu</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012050154/article/details/50903326">https://blog.csdn.net/u012050154/article/details/50903326</a></p>
<h2 id="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B"><a href="#当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B" class="headerlink" title="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B"></a>当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B</h2><p>不能，因为要进入方法B，就需要一个锁对象，有因为已经有线程进入了A方法了，说明锁对象已经被占用，则方法B的线程就会去等锁池中等待。</p>
<h2 id="线程的三种方式"><a href="#线程的三种方式" class="headerlink" title="线程的三种方式"></a>线程的三种方式</h2><ol>
<li><ul>
<li><p>继承Thread类 重写run放方法</p>
</li>
<li><p>new 该类</p>
</li>
<li><p>该类.start();</p>
</li>
</ul>
</li>
<li><ul>
<li>实现Runnable接口重写run方法</li>
<li>new 类名（）；</li>
<li>new Thread（该类名）；</li>
<li>th.start()；</li>
</ul>
</li>
<li><p> new Thread（new Runnable（）{</p>
</li>
</ol>
<p>   ​        重写run方法</p>
<p>   }）.start()；</p>
<h2 id="synchronized关键字的用法"><a href="#synchronized关键字的用法" class="headerlink" title="synchronized关键字的用法"></a>synchronized关键字的用法</h2><p>synchronized（锁对象）{代码}  锁对象相同能同步，锁对象 不同不能同步</p>
<p>synchronized 实例方法，锁对象是this。两个线程</p>
<p>如果用同一个对象的同步实例方法访问能同步</p>
<p>synchronized 静态方法 锁对象是 该类.class  ，无论如何都能同步</p>
<h2 id="List-Set-Map"><a href="#List-Set-Map" class="headerlink" title="List Set Map"></a>List Set Map</h2><p><strong>List  特性</strong>：有序可重复<br><strong>常用方法</strong>：<br>        add () 添加一个元素<br>        addAll() 参数是一个实现了Connection的集合。将这个集合中的所有元素都添加到集合中<br>        remove()传一个下标 remove掉该下标上的元素，返回true或者false 传一个Object remove掉第一次出现的        该元素。<br>        clear()清空集合<br>        set()两个参数。第一个参数是下标，第二个参数数Object 用指定的元素替换集合中指定位置的元素<br>        get();参数是下标,得到该下标的元素<br>        size();返回集合的大小<br>        toArray()<br><strong>遍历</strong>：<br>    有三种方法<br>    foreach   iterat or  普通for<br><strong>排序</strong>：<br>    1.让元素具有比较性,让元素实现Comparable接口重写CompareTo()方法; 然后使用工具了collections.sort(list);<br>    2.使用 collections.sort(list，new Comparator(){<br>        重写Compare()接口；<br>    });<br><strong>实现List接口的有ArrayList Vector LinkedList</strong><br>    ArrayList 底层是动态数组，查询块，从中间增加删除慢 线程不安全 速度快。可以使用<br>    List list = Collections.synchronizedList(new ArrayList(…)); 来线程安全化</p>
<p>​    LinkedList 底层是双向链表，查询慢，增删快。线程不安全，速度快</p>
<p>​    Vector 底层是数组，查询块，增删慢，线程安全 速度慢（已过时）</p>
<p><strong>Set 特性</strong>：无序不可重复<br>    <strong>常用方法</strong>：<br>        add,remove,contans,size,clear<br>    <strong>遍历</strong><br>        foreach iterator<br>    <strong>实现set接口的有TreeSet 和 HashSet LinkedHashSet</strong></p>
<p><strong>TreeSet</strong> </p>
<p>底层是红黑树（平衡二叉搜索树） 平衡：对于任何一个节点，左右子树的高度之差不能超过1  ，二叉搜索树： 对于任何一个节点，左子树都比该节点小，右子树都比该节点大。</p>
<p><strong>如果要存自定义的类必须定义比较规则</strong>：</p>
<p>1.集合的元素具有比较性  元素实现Comparable接口 重写Compareto方法<br>2.集合本身具有比较性   创建集合的时候传递一个匿名内部类 new Comparor() </p>
<p><strong>HashSet</strong><br><strong>如果要存自定义的类，那么自定义类中需要重写hashCode()和equals()</strong><br><em>底层是哈希表。经典的哈希表结构是由数组+链表的形式构成的。hash函数的输入是无穷大，输出是一个有限的区间。相同的输入得到相同的输出。输出的值都均匀分布。</em><br><em>先使用hash函数得到一个哈希值然后取模数组长度放到对应的桶中。比如说 元素A 放到1号桶中，再次向集合中放元素A的话得到相同的桶位置，然后使用equals看看相不相等。相等就证明是同一个元素。不进行操作。</em><br><em>如果添加一个元素B  经过计算后也是放到1号桶中。然后使用equals看看相不相等。不相等，证明不是同一个元素，然后和链表的第二个元素比较看看相不相等，以此类推，如果都不相等，就在链表的最后添加该元素</em><br><em>java中的Hash表是数组+红黑树的结构。</em></p>
<p><strong>LinkedHashSet</strong> 保证输入和输出有序。</p>
<p><strong>Map 特性：key - value  key 无序不可重复</strong><br>    <strong>常用方法</strong>：<br>        put<br>        remove<br>        clear<br>        containsKey<br>        containsValue<br>    <strong>遍历</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</span><br><span class="line">		Set&lt;Map.Entry&lt;String, String&gt;&gt; set = map.entrySet();</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String,String&gt; entry: set) &#123;</span><br><span class="line">			System.out.println(entry.getKey()+<span class="string">&quot;---&quot;</span>+entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line"><span class="number">2.</span>keySet</span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">		<span class="keyword">for</span> (String s : keySet)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;key:&quot;</span>+s+<span class="string">&quot;---value:&quot;</span>+map.get(s));</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<p><strong>HashMap</strong> : 底层是哈希表   线程不安全，效率高。能存null，如果需要将自定义类对象作为HashMap的key，那么自定义类中需要重写hashCode()和equals()<br><strong>TreeMap</strong> 底层是红黑树 如果将自定义的对象作为key 的话吗，那么需要给自定义的类实现Compareable接口或者在TreeMap的构造器中new Comparator();</p>
<p><strong>ConcurrentHashMap 线程安全，效率也高</strong><br><strong>hashTable 线程安全，效率低 ，不能存null。</strong></p>
<h2 id="java中的流"><a href="#java中的流" class="headerlink" title="java中的流"></a>java中的流</h2><p>字节流和字符流 还有缓冲流和转换流和对象流;<br>FileInputStream BufferedInputStream ObjectInputStream,InputStreamReader<br>FileReader  BufferedReader</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><strong>就是把对象变成字节序列。便于网络传输</strong></p>
<p>oos =new ObjectOutputStream(new FileOutputStream(“”));<br>oos.writeObject(new Product());<br>Product这个类要实现Serializable接口。有get set方法。如果属性使用transient，static修饰，该属性的值不能被序列化。</p>
<p><strong>反序列化就是把字节序列变成对象。</strong><br>    ObjectInputStream(new FileInputStream(“”));<br>    ois.readObject();</p>
<h2 id="打印所有文件（递归）"><a href="#打印所有文件（递归）" class="headerlink" title="打印所有文件（递归）"></a>打印所有文件（递归）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">digui</span><span class="params">()</span></span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;F:\\学习文件\\刘意视频\\刘意视频源码\\day20_递归_字节流&quot;</span>);</span><br><span class="line">    printName(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (file==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">for</span> (File temp:files)&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.isDirectory())&#123;</span><br><span class="line">            printName(temp);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(temp.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="jdbc-操作数据库"><a href="#jdbc-操作数据库" class="headerlink" title="jdbc 操作数据库"></a>jdbc 操作数据库</h2><p>1.加载驱动：class.forName(“数据库连包”);<br>2.获取连接：driverManner.getConnection();<br>3.创建sql con.preparedStatement(“”); ps.setInt(1,””);<br>4.执行sql ps.excuteQuery();  返回一个ResultSet rs   </p>
<ul>
<li>ps.excute() 增删改放回false  查询返回true。然后在调用getResultSet() 和getUpdateCount（）来处理数据</li>
<li>ps.excuteUpdate() 增删改用这个，返回影响行数</li>
</ul>
<p>5.处理结果 while(rs.next){rs.getInt(“empno”);}<br>6.关闭流</p>
<h2 id="Statement和PreparedStatement有什么区别？哪个性能更好？"><a href="#Statement和PreparedStatement有什么区别？哪个性能更好？" class="headerlink" title="Statement和PreparedStatement有什么区别？哪个性能更好？"></a>Statement和PreparedStatement有什么区别？哪个性能更好？</h2><p>1.可以带参数，避免了麻烦且不安全的字符串拼接，防止sql注入<br>2.性能高，因为每一个preparestatement都和一个sql模板绑定在一起，先把sql模板传给数据库，数据库检验，编译，然后传参，第二次执行的时候就直接传参就行了。</p>
<h2 id="连接池："><a href="#连接池：" class="headerlink" title="连接池："></a>连接池：</h2><p>创建连接和销毁连接需要耗费大量的资源，尤其是服务器不在本地，需要tcp3次握手来创建连接，4次挥手关闭连接，所以事先创建好若干个连放入pool中，使用的时候直接从池中拿试用完毕后也不需要关闭，归还给连接池就可以。提升了系统访问数据库的效率，连接池也就是典型的空间换时间的列子</p>
<h2 id="六原则一法则："><a href="#六原则一法则：" class="headerlink" title="六原则一法则："></a>六原则一法则：</h2><p>单一职责原则：一个类只做他应该做的事情<br>开闭原则；一个软件体系只对扩开房，对修改关闭<br>依赖倒置原则：面向接口编程<br>里氏替换原则：子类可以替换父类<br>接口隔离原则：一个接口的功能应该小儿专，不能大而全<br>合成聚合复用原则：推荐使用合成或者聚合的关系来复用代码<br>迪米特法则：一个类应该对其他类尽可能少的了解</p>
<h2 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h2><p>原子性：事务中的操作时不可再分割的，要么全部成功，要么全部失败<br>一致性：事务操作前后业务数据保持一致<br>隔离性：事务并发操作的时候要隔离开来<br>持久性：数据到达数据库后不能再出现意外，哪怕是数据库崩溃了，也要通过日志来回复过来</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><ol>
<li>一个对象被创建后放置在JVM的堆内存中，只有当程序中没其他的对象引用他时才有可能被释放</li>
<li>垃圾回收机制是系统级守护线程，用来跟踪正在使用的对象，检查并回收不在使用的变量</li>
<li>可以有效的解决因为动态内存分配导致的两大问题，因垃圾过多导致内存耗尽，因为非法的释放内存导致内存的非法引用</li>
<li>可以调用System.gc 和 Runtime.gc 来催促系统尽快回收垃圾，但是垃圾回收机制对于程序员来时是透明的，不能精准的操控垃圾回收机制</li>
<li>JVM会让对象调用finallize方法来进行回收，但是finallize可能会造成该对象的复活，导致垃圾回收机制取消该内存的释放，如果垃圾回收机制抛出异常，不会导致程序终止</li>
</ol>
<h2 id="amp-和-amp-amp-，-和-区别"><a href="#amp-和-amp-amp-，-和-区别" class="headerlink" title="&amp;和&amp;&amp;，|和| |区别"></a>&amp;和&amp;&amp;，|和| |区别</h2><p>单一个&amp; | 的话要判断左右两边的，如果是短路&amp;&amp;，左边是false 就不判断右边的了 ||如果左边是true，就不判断右边的了</p>
<h2 id="全局变量、局部变量"><a href="#全局变量、局部变量" class="headerlink" title="全局变量、局部变量"></a>全局变量、局部变量</h2><p>全局变量：类中方法外，系统默认给初始值。如果是final修饰的话必须在声明的时候就赋值<br>局部变量：定义在方法里，形参。</p>
<h2 id="方法的参数"><a href="#方法的参数" class="headerlink" title="方法的参数"></a>方法的参数</h2><p>参数是基本数据类型 ， 形参的改变不影响实参</p>
<p>参数是引用数据类型， 如果该参数不指向其他内存的话，形参的改变影响实参</p>
<h2 id="do-while和while区别"><a href="#do-while和while区别" class="headerlink" title="do-while和while区别"></a>do-while和while区别</h2><p>do while 先执行一次，在判断</p>
<p>while 先 判断 在执行</p>
<h2 id="final、fianlly、finalize"><a href="#final、fianlly、finalize" class="headerlink" title="final、fianlly、finalize"></a>final、fianlly、finalize</h2><p>final 修饰类，类不能被继承，修饰方法，方法不能被重写，修饰属性，修饰基本数据类型，该值不能改变，修饰引用数据类型，该变量不能指向新的内存空间，修饰 全局变量，必须在声明的时候赋值，修饰局部变量，可以后赋值</p>
<p>finally 和 try catch 配合使用，用于异常处理，不论try 里面 报不报异常，都会指向finally</p>
<p>finalize 用来提醒垃圾回收机制过来回收这个内存</p>
<h2 id="父子类实例化对象过程"><a href="#父子类实例化对象过程" class="headerlink" title="父子类实例化对象过程"></a>父子类实例化对象过程</h2><p>父类静态</p>
<p>子类静态</p>
<p>父类构造代码块，父类构造方法</p>
<p>子类构造代码块，子类构造方法</p>
<h2 id="访问权限修饰"><a href="#访问权限修饰" class="headerlink" title="访问权限修饰"></a>访问权限修饰</h2><p>public 所有<br>protected 本类，本包，父子类<br>default 本类，本包<br>private 本类</p>
<h2 id="抽象类接口的区别"><a href="#抽象类接口的区别" class="headerlink" title="抽象类接口的区别"></a>抽象类接口的区别</h2><table>
<thead>
<tr>
<th></th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>有</td>
<td>没有</td>
</tr>
<tr>
<td>抽象方法</td>
<td>可以有可以没有 不可以省略abstract</td>
<td>所有方法都是抽象的可以省略abstract</td>
</tr>
<tr>
<td>属性</td>
<td>无要求</td>
<td>只能是public static final 常量</td>
</tr>
<tr>
<td>继承关系</td>
<td>只能有一个父类</td>
<td>可以有多个父接口</td>
</tr>
<tr>
<td>方法要求</td>
<td>抽象类中的方法都是子类共有的方法，类满足必      须是  抽象类子类的关系</td>
<td>定义无关类的公共行为，这些类都要遵循相同的行为协议</td>
</tr>
<tr>
<td>访问权限修饰符</td>
<td>默认是default</td>
<td>默认是public</td>
</tr>
</tbody></table>
<h2 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h2><p>StringBuffer 线程安全，效率低，StringBuilder 线程不安全，效率高</p>
<p>为了解决字符串频繁拼接，导致频繁的创建无用的对象影响性能，多线程用Buffer，单线程用Builder 方法为append</p>
<h2 id="Collection-和-Collections-的区别"><a href="#Collection-和-Collections-的区别" class="headerlink" title="Collection 和 Collections 的区别"></a>Collection 和 Collections 的区别</h2><p>Collection 是 List 和Set的父接口，Collections是操作集合的工具类，里面有静态方法用来排序，二分，线程安全化，乱序等</p>
<h2 id="Error-和Exception-的区别"><a href="#Error-和Exception-的区别" class="headerlink" title="Error 和Exception 的区别"></a>Error 和Exception 的区别</h2><p> Exception和Error都是Throwable的子类 </p>
<p> Exception是java程序运行中可预料的异常情况，咱们可以获取到这种异常，并且对这种异常进行业务外的处理。 </p>
<p> Error是java程序运行中不可预料的异常情况，这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等。 </p>
<p>其中的Exception又分为检查性异常和非检查性异常。两个根本的区别在于，检查性异常 必须在编写代码时，使用try catch捕获（比如：IOException异常）。非检查性异常 在代码编写使，可以忽略捕获操作（比如：ArrayIndexOutOfBoundsException），这种异常是在代码编写或者使用过程中通过规范可以避免发生的。<br>原文链接：[](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin">https://blog.csdn.net/weixin</a></p>
<p>_42124070/article/details/80833629)</p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/carson073/article/details/90665131">https://blog.csdn.net/carson073/article/details/90665131</a>  springmvc 转发和重定向</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/17/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AF%95%E9%A2%98/" data-id="ckn4703xr005r0svh6ncg5qsv" data-title="基础笔试题" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-前缀树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/15/%E5%89%8D%E7%BC%80%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2020-01-15T10:08:45.000Z" itemprop="datePublished">2020-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/15/%E5%89%8D%E7%BC%80%E6%A0%91/">前缀树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>前缀树其实也是树</p>
<p>比如说有几个字符串   “abc”，</p>
<p>还有一个头节点</p>
<img src="F:/blogPic/image-20200115193802178.png" alt="image-20200115193802178" style="zoom:50%;" />

<p><em><strong>要把“abc”这个字符串加到这棵树上</strong></em></p>
<p>这个头节点没有走向a的路，所以</p>
<img src="F:/blogPic/image-20200115193833100.png" alt="image-20200115193833100" style="zoom:50%;" />

<p>注意，字母是填在路上的</p>
<p>然后看当前节点有没有一条走向b的路。没有，然后添加一个节点</p>
<img src="F:/blogPic/image-20200115194046183.png" alt="image-20200115194046183" style="zoom:50%;" />

<p>有没有走向c的路？没有，那就添加一个节点</p>
<img src="F:/blogPic/image-20200115194207954.png" alt="image-20200115194207954" style="zoom:50%;" />

<p><em><strong>现在还要把“bce”添加到这棵树中</strong></em></p>
<p>从头节点开始有没有走向b的路？没有，所以添加一个节点：（因为前缀不同，上来就走了两条路）</p>
<img src="F:/blogPic/image-20200115194409660.png" alt="image-20200115194409660" style="zoom:50%;" />

<p>以此类推，吧“bce”添加进去后，树的形状是：</p>
<img src="F:/blogPic/image-20200115194505542.png" alt="image-20200115194505542" style="zoom:50%;" />

<p><em><strong>现在，要把“abd” 加入到这颗树中</strong></em></p>
<ul>
<li><p>头节点有没有走向a的路？<em><strong>有</strong></em></p>
<p> 复用，不重复建造节点</p>
</li>
<li><p>然后看走向a的那个节点有没有走向b的路？ 有</p>
<p>继续复用</p>
</li>
<li><p>然后看走向b的这个节点有没有走向d的路？没有</p>
<p>创建一个节点，路径为d：</p>
<img src="F:/blogPic/image-20200115194935342.png" alt="image-20200115194935342" style="zoom:50%;" /></li>
</ul>
<p><strong>同样的道理，把“bef ”加入到树中</strong></p>
<img src="F:/blogPic/image-20200115195141249.png" alt="image-20200115195141249" style="zoom:50%;" />

<h3 id="作用1"><a href="#作用1" class="headerlink" title="作用1"></a>作用1</h3><p>​        比如现在已经加入了n个字符串</p>
<p>​        <strong>我想让你查一下，是否某一个字符串是以“be”开始的</strong></p>
<p>​        很好查的。有走向b的路么？有，有走向e的路么？有。</p>
<p>​        所以一定有字符串是以be开头的</p>
<h3 id="作用2"><a href="#作用2" class="headerlink" title="作用2"></a>作用2</h3><p>​        <strong>现在查一下，你加的字符串中，有没有加入过“be”这个字符串</strong></p>
<p>​        以前的结构不够用了，因为be是被复用的，无法找出加没加过be。</p>
<p>​        <strong>所以现在加上一个属性：有多少个字符串是以此字符结尾的</strong></p>
<p>​        此时：刚才那棵树就变成了这个样子：</p>
<img src="F:/blogPic/image-20200115201130131.png" alt="image-20200115201130131" style="zoom:50%;" />

<p>​        如果你找be 的话，你找到e后看看这个节点是0还是几？</p>
<p>​        就可以找到有多少个字符串是以be结尾的了</p>
<h3 id="作用3"><a href="#作用3" class="headerlink" title="作用3"></a>作用3</h3><p>​        我给你一个字符串</p>
<p>​        <strong>请你告诉我，有多少个字符串以他作为前缀？</strong></p>
<p>​        <strong>在加入一个数据项：每一个节点被划过多少次</strong></p>
<p>​        就可以统计出有多少个了</p>
<p><strong>代码细节</strong>：</p>
<p><strong>如何检查下一个路存不存在</strong>？</p>
<p>因为你提前准备好了26条路，而且都没有挂东西，都是null</p>
<p>检查一条路指的节点是不是null这件事来标记这条路存在不存在</p>
<p>删除的时候，怎么插入的就怎么删，但是有一点区别</p>
<img src="F:/blogPic/image-20200115212421247.png" alt="image-20200115212421247" style="zoom:80%;" />

<p>我要删除abc的话，就是沿途path–，最后end-1</p>
<p>但是如果删的时候，词频已经是1个了，比如说kgzte </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="comment">//有多少个字符串到达过这个节点</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> path;</span><br><span class="line">        <span class="comment">//有多少个字符串是以这个个节点结尾的</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">        <span class="comment">//这个是路，比如说，强行规定只能是26个字母,小写，a-z</span></span><br><span class="line">		<span class="keyword">public</span> TrieNode[] nexts;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			path = <span class="number">0</span>;</span><br><span class="line">			end = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//那这个节点就有26条路</span></span><br><span class="line">			nexts = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这个就是头</span></span><br><span class="line">		<span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//删除</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//存在才删嘛，不存在直接返回</span></span><br><span class="line">			<span class="keyword">if</span> (search(word) != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">				TrieNode node = root;</span><br><span class="line">				<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">					index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                    <span class="comment">//如果path--变成0了，底下的直接为null，然后return</span></span><br><span class="line">					<span class="keyword">if</span> (--node.nexts[index].path == <span class="number">0</span>) &#123;</span><br><span class="line">						node.nexts[index] = <span class="keyword">null</span>;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					node = node.nexts[index];</span><br><span class="line">				&#125;</span><br><span class="line">				node.end--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询和插入一样，都是挨个儿找，只不过最后不进行path++，而是把该节点的node返回</span></span><br><span class="line">        <span class="comment">//来判断有么有该字符串</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (word == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">			TrieNode node = root;</span><br><span class="line">			<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">				index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">				<span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果下一个是null的话，表名根本就么有这个字符串</span></span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				node = node.nexts[index];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> node.end;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//求某一个字符串，前缀的数量是多少</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNumber</span><span class="params">(String pre)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">char</span>[] chs = pre.toCharArray();</span><br><span class="line">			TrieNode node = root;</span><br><span class="line">			<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">				index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="comment">//如果找的找的发现没有了，说明没有这个前缀</span></span><br><span class="line">				<span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				node = node.nexts[index];</span><br><span class="line">			&#125;</span><br><span class="line">             <span class="comment">//找到最后一个字符停，看他的path是多少</span></span><br><span class="line">			<span class="keyword">return</span> node.path;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line">		System.out.println(trie.search(<span class="string">&quot;zuo&quot;</span>));</span><br><span class="line">		trie.insert(<span class="string">&quot;zuo&quot;</span>);</span><br><span class="line">		System.out.println(trie.search(<span class="string">&quot;zuo&quot;</span>));</span><br><span class="line">		trie.delete(<span class="string">&quot;zuo&quot;</span>);</span><br><span class="line">		System.out.println(trie.search(<span class="string">&quot;zuo&quot;</span>));</span><br><span class="line">		trie.insert(<span class="string">&quot;zuo&quot;</span>);</span><br><span class="line">		trie.insert(<span class="string">&quot;zuo&quot;</span>);</span><br><span class="line">		trie.delete(<span class="string">&quot;zuo&quot;</span>);</span><br><span class="line">		System.out.println(trie.search(<span class="string">&quot;zuo&quot;</span>));</span><br><span class="line">		trie.delete(<span class="string">&quot;zuo&quot;</span>);</span><br><span class="line">		System.out.println(trie.search(<span class="string">&quot;zuo&quot;</span>));</span><br><span class="line">		trie.insert(<span class="string">&quot;zuoa&quot;</span>);</span><br><span class="line">		trie.insert(<span class="string">&quot;zuoac&quot;</span>);</span><br><span class="line">		trie.insert(<span class="string">&quot;zuoab&quot;</span>);</span><br><span class="line">		trie.insert(<span class="string">&quot;zuoad&quot;</span>);</span><br><span class="line">		trie.delete(<span class="string">&quot;zuoa&quot;</span>);</span><br><span class="line">		System.out.println(trie.search(<span class="string">&quot;zuoa&quot;</span>));</span><br><span class="line">		System.out.println(trie.prefixNumber(<span class="string">&quot;zuo&quot;</span>));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/15/%E5%89%8D%E7%BC%80%E6%A0%91/" data-id="ckn4703wl001z0svhh2gq9rin" data-title="前缀树" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-岛问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/14/%E5%B2%9B%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2020-01-14T14:22:10.000Z" itemprop="datePublished">2020-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/14/%E5%B2%9B%E9%97%AE%E9%A2%98/">岛问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>岛问题</p>
<p>岛问题 </p>
<p>一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右 </p>
<p>四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个 </p>
<p>矩阵中有多少个岛？ </p>
<p>举例： </p>
<img src="http://ww1.sinaimg.cn/large/9c52df3dly1gax34rkveqj208p06ijr9.jpg" alt="image-20200114222441997"  />

<p>这个矩阵中有三个岛。</p>
<hr>
<p>两个for循环来遍历这个数组。</p>
<p>如果遇到一个1，就执行感染函数。把这一片的1 都变成2</p>
<img src="http://ww1.sinaimg.cn/large/9c52df3dly1gax37gmznjj20pa0i677y.jpg" alt="image-20200114222726444" style="zoom:33%;" />

<p>比如，感染后</p>
<img src="http://ww1.sinaimg.cn/large/9c52df3dly1gax36h24l4j20q20jzdku.jpg" alt="image-20200114222802011" style="zoom:33%;" />

<p>感染过程完成后，岛的数量+1</p>
<p>然后我在遍历下一个数，已经是2 了，跳到下一个，</p>
<p>当然，遇到0也直接跳下一个，</p>
<p>直到遇到第二个1，进行感染。如下图：</p>
<img src="http://ww1.sinaimg.cn/large/9c52df3dly1gax36h2o25j20ou0ibjxq.jpg" alt="image-20200114223052014" style="zoom:33%;" />

<p>然后岛数量+1,</p>
<p>以此类推， 总共有3个岛</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countIslands</span><span class="params">(<span class="keyword">int</span>[][] m)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m == <span class="keyword">null</span> || m[<span class="number">0</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//N和M是行和列</span></span><br><span class="line">		<span class="keyword">int</span> N = m.length;</span><br><span class="line">		<span class="keyword">int</span> M = m[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">                <span class="comment">//for循环的过程中如果是1，进入到感染函数</span></span><br><span class="line">				<span class="keyword">if</span> (m[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">					res++;<span class="comment">//岛数量+1</span></span><br><span class="line">					infect(m, i, j, N, M);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> N, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//感染的过程如果遇到不是1，或者越界，直接return</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= N || j &lt; <span class="number">0</span> || j &gt;= M || m[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//当前位置变成2，再去感染他的上，右，下，左</span></span><br><span class="line">		m[i][j] = <span class="number">2</span>;</span><br><span class="line">		infect(m, i + <span class="number">1</span>, j, N, M);</span><br><span class="line">		infect(m, i - <span class="number">1</span>, j, N, M);</span><br><span class="line">		infect(m, i, j + <span class="number">1</span>, N, M);</span><br><span class="line">		infect(m, i, j - <span class="number">1</span>, N, M);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[][] m1 = &#123;  &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, </span><br><span class="line">				        &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;, </span><br><span class="line">				        &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">				        &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, </span><br><span class="line">				        &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, </span><br><span class="line">				        &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">				        &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#125;;</span><br><span class="line">		System.out.println(countIslands(m1));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span>[][] m2 = &#123;  &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, </span><br><span class="line">						&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;, </span><br><span class="line">						&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">						&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;, </span><br><span class="line">						&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, </span><br><span class="line">						&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">						&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#125;;</span><br><span class="line">		System.out.println(countIslands(m2));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>如果是特别大的矩阵，我要分成4块，分别求出岛的数量。然后合并结果</p>
<img src="http://ww1.sinaimg.cn/large/9c52df3dly1gax36gvvj1j20r00kr42u.jpg" alt="image-20200114224138437" style="zoom:33%;" />

<p>举一个简单的例子，合并两个</p>
<img src="http://ww1.sinaimg.cn/large/9c52df3dly1gax36gtjf2j20qw0c10ux.jpg" alt="image-20200114230212760" style="zoom:33%;" />

<p>各自算出岛数量，然后考虑边界信息</p>
<p>比如：</p>
<img src="http://ww1.sinaimg.cn/large/9c52df3dly1gax36guqyqj20ti0l7ted.jpg" alt="image-20200114230410372" style="zoom:50%;" />

<p>没有1的位置都是0，左边有3个岛，右边有2个岛。</p>
<p>实际上，连成一片只有4个岛，</p>
<p>你只要收集边界信息，就足以查出岛数量了</p>
<p>只是你有了边界信息后应该如何计算</p>
<p>比如上面的例子，还要保证不重复减的操作</p>
<p>比如：</p>
<img src="http://ww1.sinaimg.cn/large/9c52df3dly1gax36gtrdcj20wd0ibwi3.jpg" alt="image-20200114230837988" style="zoom: 33%;" />

<p>其实只有1个岛 </p>
<p>例子：</p>
<img src="http://ww1.sinaimg.cn/large/9c52df3dly1gax36gzsesj20tz0kzk1u.jpg" alt="image-20200114231721359" style="zoom:50%;" />

<p>每一块都有一个感染中心。</p>
<p>只需要求出两个信息。有几个岛？边界的感染中心是谁？ </p>
<p>现在左边两个岛，右边两个岛</p>
<ul>
<li><p>第一行的边界：</p>
<p>求A所在集合和C所在集合是否是同一个集合</p>
<p>如果不是，说明A所在集合和C所在集合之前没有合并过，<em><strong>岛的 数量-1</strong></em></p>
<p>查完之后，把他合并在一起</p>
</li>
<li><p>第二行的边界：</p>
<p>A所在的集合和C所在的集合是不是一个？</p>
<p>是一个，所以不-1</p>
</li>
<li><p>第三行的边界</p>
<p>  左边是0，右边是1，不管</p>
</li>
<li><p>第四行的边界</p>
<p>左右两边都是1 ，管</p>
<p>查B所在集合和C是不是同一个集合</p>
<p>不是</p>
<p>岛数量-1</p>
<p>合并。</p>
</li>
<li><p>第五行的边界</p>
<p>左右两边不全是1 ，不管</p>
</li>
</ul>
<p>所以，结果岛的数量是2</p>
<hr>
<p>如果切成很多份的话。类似，每一块求出岛的数量，和四个边界信息处于哪一个岛</p>
<p>分布式系统中使用同一个并查集（使用spark）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/14/%E5%B2%9B%E9%97%AE%E9%A2%98/" data-id="ckn4703wq002a0svh38bwbxen" data-title="岛问题" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-并查集" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/14/%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="article-date">
  <time class="dt-published" datetime="2020-01-14T11:05:44.000Z" itemprop="datePublished">2020-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/14/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>作用：</p>
<ol>
<li><p>非常快的检查两个元素是否属于一个集合</p>
<ul>
<li>A所在的集合在set1，B所在的集合在set2，查他两个东西是不是在一个集合</li>
<li>一个集合可以设置成很多结构，比如说list 每个元素为node， A在list1 中，B在list2 中，通过A的到list1 ，然后看看list1中有没有B，这样不够好，需要遍历</li>
</ul>
</li>
<li><p>两个元素各自所在的集合，合并在一起</p>
<ul>
<li><p>A所在的集合set1，set2 ，set3  和B所在的集合set4，set5，set6  这6个集合合并在一起</p>
</li>
<li><p> 以后 这6 个里面的元素都在这个大集合里</p>
</li>
<li><p>假如要把set2中的内容全都给set1 ，就要遍历set2 ，这样不够好</p>
</li>
</ul>
</li>
<li><p>你要想用并查集，就要在第一步的时候把 所有的数据样本给他，不能是动态的（流）</p>
</li>
</ol>
<p>一开始，把所有的数据样本给你，比如说，一开始给你5个数：</p>
<p>第一步，把每一个数都弄成一个集合，这个集合里面只有这一个数，并且向上的节点是指回自己的</p>
<img src="http://ww1.sinaimg.cn/large/9c52df3dly1gax10akip0j20y207k422.jpg" alt="image-20200114192657092" style="zoom:50%;" />

<p>自己是这个集合的代表节点</p>
<p>集合合并：</p>
<p>比如说1 这个集合和2 这个集合合并，就是这个样子</p>
<img src="F:/blogPic/image-20200114192917240.png" alt="image-20200114192917240" style="zoom:50%;" />

<p>2的代表节点是谁？通过2 往上找，找到某一个节点，他的指针指回了自己，该节点就是2 的代表节点</p>
<p>如果3要和这结构合并。</p>
<img src="http://ww1.sinaimg.cn/large/9c52df3dly1gax10vcw9kj20t90mdjxz.jpg" alt="image-20200114193608573" style="zoom:50%;" />

<p>3的代表节点同上</p>
<hr>
<p>说白了，这个结构就是一个多叉树，</p>
<img src="http://ww1.sinaimg.cn/large/9c52df3dly1gax138tvs1j20nc0n0q7y.jpg" alt="image-20200114193838796" style="zoom:50%;" />

<p>那么如何判断A和B是不是在一个集合？</p>
<p>就是A不断向上找，找到代表的节点停，B不断向上找，找到代表的节点停</p>
<p>如果他俩代表节点是同一个，表示在同一个集合里，如果是同一个代表节点，则不在同一个集合中</p>
<hr>
<p>合并集合</p>
<img src="http://ww1.sinaimg.cn/large/9c52df3dly1gax13yfwfqj20ye0eraf1.jpg" alt="image-20200114194237962" style="zoom:33%;" />

<p>比如3，和5 所在的集合要合并 </p>
<p>3 找到1,5 找到4</p>
<p>判断哪一个集合元素多。 1 这个多 </p>
<p>把少元素的挂在多元素的底下</p>
<img src="http://ww1.sinaimg.cn/large/9c52df3dly1gax14hhzhrj20e50hkmzk.jpg" alt="image-20200114194640203" style="zoom:33%;" />

<p><em><strong>优化</strong></em></p>
<img src="F:/blogPic/image-20200114195158481.png" alt="image-20200114195158481" style="zoom:33%;" />

<p>整个路径上的东西，在我查完之后，同一给他打平，如果4底下还有节点的话，不管。从4开始打扁平。</p>
<img src="http://ww1.sinaimg.cn/large/9c52df3dly1gax1585yauj20h908sjtu.jpg" alt="image-20200114200650067" style="zoom:33%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="comment">// whatever you like</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前一个Node代表这个节点，后一个Node代表这个节点的父节点</span></span><br><span class="line">		<span class="keyword">public</span> HashMap&lt;Node, Node&gt; fatherMap;</span><br><span class="line">        <span class="comment">//某一个节点，所在的集合，一共有多少个节点</span></span><br><span class="line">        <span class="comment">//Node 不表示Node的属性，表示Node所在集合的属性，代表节点</span></span><br><span class="line">		<span class="keyword">public</span> HashMap&lt;Node, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化。一次性把所有样本都给我，</span></span><br><span class="line">        <span class="comment">//把每个节点当成一个集合</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span><span class="params">(List&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line">			fatherMap = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line">			sizeMap = <span class="keyword">new</span> HashMap&lt;Node, Integer&gt;();</span><br><span class="line">             makeSets(nodes);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeSets</span><span class="params">(List&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">                <span class="comment">//每一个节点自己形成一个集合</span></span><br><span class="line">				fatherMap.put(node, node);</span><br><span class="line">                <span class="comment">//自己就是代表节点，size是1</span></span><br><span class="line">				sizeMap.put(node, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找代表节点，并变扁平</span></span><br><span class="line">		<span class="function"><span class="keyword">private</span> Node <span class="title">findHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//找到father节点。</span></span><br><span class="line">			Node father = fatherMap.get(node);</span><br><span class="line">            <span class="comment">//如果father节点不是自己，递归</span></span><br><span class="line">			<span class="keyword">if</span> (father != node) &#123;</span><br><span class="line">				father = findHead(father);</span><br><span class="line">			&#125;</span><br><span class="line">			fatherMap.put(node, father);</span><br><span class="line">			<span class="keyword">return</span> father;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//A 所在集合和B所在集合的代表节点是否是同一个</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> findHead(a) == findHead(b);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Node aHead = findHead(a);</span><br><span class="line">			Node bHead = findHead(b);</span><br><span class="line">            <span class="comment">//如果不在同一个集合中，就需要合并</span></span><br><span class="line">			<span class="keyword">if</span> (aHead != bHead) &#123;</span><br><span class="line">                <span class="comment">//取得A所在集合的size B所在集合的size</span></span><br><span class="line">				<span class="keyword">int</span> aSetSize= sizeMap.get(aHead);</span><br><span class="line">				<span class="keyword">int</span> bSetSize = sizeMap.get(bHead);</span><br><span class="line">                <span class="comment">//如果A的size小</span></span><br><span class="line">				<span class="keyword">if</span> (aSetSize &lt;= bSetSize) &#123;</span><br><span class="line">                    <span class="comment">//把Ahead的代表节点换成Bhead，</span></span><br><span class="line">                    <span class="comment">//把A所在的集合的代表节点挂在B所在集合的代表节点的底下</span></span><br><span class="line">					fatherMap.put(aHead, bHead);</span><br><span class="line">                    <span class="comment">//然后BHead所代表的集合的大小改变</span></span><br><span class="line">					sizeMap.put(bHead, aSetSize + bSetSize);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					fatherMap.put(bHead, aHead);</span><br><span class="line">					sizeMap.put(aHead, aSetSize + bSetSize);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>非递归版本的findFather和变扁平</p>
<img src="http://ww1.sinaimg.cn/large/9c52df3dly1gax16isyyjj20k60crag4.jpg" alt="image-20200114205754462" style="zoom: 67%;" />


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/14/%E5%B9%B6%E6%9F%A5%E9%9B%86/" data-id="ckn4703wv002v0svh60z0e4pa" data-title="并查集" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-springmvc" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/12/springmvc/" class="article-date">
  <time class="dt-published" datetime="2020-01-12T14:35:45.000Z" itemprop="datePublished">2020-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/12/springmvc/">springmvc</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>表现层四件事</p>
<h3 id="响应jsp页面请求"><a href="#响应jsp页面请求" class="headerlink" title="响应jsp页面请求"></a>响应jsp页面请求</h3><ul>
<li><p>后台：</p>
<pre><code>       Controller类写注解@RequestMapping(value=&quot;user&quot;)，叫做窄化请求
       Controller方法写注解@RequestMapping(value=&quot;add&quot;)，响应请求
       如果后台没有窄化请求,jsp页面请求：&lt;%=basePath%&gt;add.action
       如果后台有窄化请求,jsp页面请求：&lt;%=basePath%&gt;user/add.action
</code></pre>
</li>
<li><p>前台jsp</p>
<ol>
<li><p>```html<br><a href="<%=basePath%>add.action">提交请求</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;html</span><br><span class="line">   &lt;form action&#x3D;&quot;&lt;%&#x3D;basePath%&gt;add.action&quot; onsubmit&#x3D;&quot;return add()&quot;&gt;</span><br><span class="line">   	&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交请求&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure></li>
<li><pre><code class="html">&lt;form action=&quot; &quot; name=&quot;myform&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;提交请求&quot;  onclick=&quot;add()&quot;&gt;
&lt;/form
    &lt;script&gt;
        function add()&#123;
        document.myform.action = &quot;&lt;%=basePath%&gt;add.action&quot;;
        document.myform.submit();
        &#125;
    &lt;/script&gt;
</code></pre>
</li>
</ol>
<p>​            </p>
<h3 id="获取jsp页面的值"><a href="#获取jsp页面的值" class="headerlink" title="获取jsp页面的值"></a>获取jsp页面的值</h3><p>​        表单中的input标签的name属性值 和 超链接中=号左边的单词</p>
<p>​        只要和请求的方法的形参的参数名相同就可以了，还可以使用request.getParametor()来获取把前台的数据封装到POJO中，方法的形参写 POJO pojo就行，此时前台中得name的值就不是参数名了，而是pojo的属性名。如果是复杂pojo ，name的值也可以是pojo的属性名.属性名。后台向前台传值</p>
</li>
</ul>
<h3 id="向jsp页面传值"><a href="#向jsp页面传值" class="headerlink" title="向jsp页面传值"></a>向jsp页面传值</h3><p>springMVC 可以用ModelAndView.addObject(“obj”,obj)来传递</p>
<p>或者在参数中声明一个Model model ，使用model.addAttribute(“obj”,obj);</p>
<h3 id="跳转jsp页面"><a href="#跳转jsp页面" class="headerlink" title="跳转jsp页面"></a>跳转jsp页面</h3><p>​    springMVC配好视图解析器后直接return”jsp页面的名字” 或者ModelAndView .setViewName(“jsp页面的名字”);<br>​    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/12/springmvc/" data-id="ckn4703w3000o0svh55cyg8k6" data-title="springmvc" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-mybatis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/12/mybatis/" class="article-date">
  <time class="dt-published" datetime="2020-01-12T09:54:45.000Z" itemprop="datePublished">2020-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/12/mybatis/">mybatis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>首先搭建好环境后</p>
<p>在sqlMapConfig.xml文件中设置别名和扫描包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;cn.hqyj.beans&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;cn.hqyj.vo&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;cn.hqyj.mapper&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<ol>
<li><p>创建接口UserMapper.java </p>
</li>
<li><p>创建UserMapper.xml</p>
</li>
<li><p>创建 测试类</p>
<ul>
<li><p>获得session后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>对应关系：</p>
<p>​         xml文件名要和接口文件名一样</p>
<p>​        xml文件中的namespace 是 接口的全类名</p>
<p>​        xml 中 增删改查标签的id是接口中的方法名</p>
<p>​        已经配过别名后resultType 和 parameterType 都可以是 该包下bean对象的类名，不区分大小写</p>
<p>​        如果parameterType 是基本数据类型（包含String） #{随便写}，${只能写value}</p>
<p>​        如果是pojo的话，$,#,中都写  pojo中的属性名，</p>
<p>​        如果pojo的属性是pojo的话，就属性名.属性</p>
<p>​        parameterType不能是List ，也就是说前台只能把List放到POJO中传给Mapper</p>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>​    1.接口中方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(User user)</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>xml 中的配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    insert into user (name,sex)  values (#&#123;name&#125;,#&#123;sex&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>​    1.  接口中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br></pre></td></tr></table></figure>

<p>​    2. xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Integer&quot;</span>&gt;</span></span><br><span class="line">    delete from user where  cid = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><ol>
<li><p>接口中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(User user)</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>xml</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateClass&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Classes&quot;</span>&gt;</span></span><br><span class="line">       update classes set username = #&#123;username&#125; where cid = #&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><h5 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h5><ul>
<li><p>在一的一方写一个List属性泛型为多的一方的类名</p>
</li>
<li><p>xml中的写法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAllMag&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;querymsg&quot;</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;querymsg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;classes&quot;</span>&gt;</span> 返回值类型</span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;cid&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;studentList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h5><ul>
<li><p>bean中在有外键的一方写外键对应的属性</p>
</li>
<li><p>xml中的写法 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAllMsgByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;queryAllMsg&quot;</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;queryAllMsg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;classes&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;classes&quot;</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;cid&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;className&quot;</span> <span class="attr">property</span>=<span class="string">&quot;className&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name like &#39;%$&#123;value&#125;%&#39;</span><br></pre></td></tr></table></figure>



<p>如果参数list需要迭代</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select * from user</span><br><span class="line">    <span class="comment">&lt;!-- foreach:循环放入参数的集合;collection:传入的集合的变量名称;item：每次循环将循环出的数据放到这个变量中</span></span><br><span class="line"><span class="comment">    open：开始循环拼接的字符;close： 结束循环拼接的字符;separater：循环中拼接的字符--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ids!=null&quot;</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">#&#123;id&#125;            </span><br><span class="line">   		<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/12/mybatis/" data-id="ckn4703vx000e0svhfm2jebnq" data-title="mybatis" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SQL练习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/09/SQL%E7%BB%83%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2020-01-09T13:03:02.000Z" itemprop="datePublished">2020-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>把列看成变量，把where 后面看成if（flag）里的exp 里的表达式</li>
<li>哪些行被取出来？ 哪一行能让flag为真，哪一行就能被取出来</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where 1&gt;2</span><br></pre></td></tr></table></figure>

<p>1&gt;2 的表达式永远为false 所以一行也取不到</p>
<p>既然是变量，就可以比较和运算，</p>
<p>where是对表中的数据发挥作用，查询出数据来</p>
<p>where发挥作用是，表示并没有discount列，发挥完才有discount列，所以，对结果中的列，要用having</p>
<p>再次筛选，就要用having</p>
<p>列就是变量，在每一行上，列的值都在变化。</p>
<p>Where 条件是表达式，在哪一行上表达式为真。哪一行就取出来</p>
<p><img src="http://ww1.sinaimg.cn/large/9c52df3dgy1gaqlz3g820j209y0dmmzl.jpg" alt="image-20200108204009669"></p>
<p>update main set num = num-(num%10) where num between 20 and 39</p>
<p>把num 一定当成变量来看，因此num/10 取整 再乘以10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update main set num &#x3D; floor(num&#x2F;10)*10  where num &gt;&#x3D;20 and num &lt;&#x3D;39;</span><br></pre></td></tr></table></figure>

<p>count（字段）和count（*）的区别，count（字段）查出来的是该字段不为null的所有行数，</p>
<p>而count（*）会查出绝对行数，就算着一行全是null ，也算一行</p>
<p>count（*） 和count（1）的区别</p>
<p>对于myisam引擎来说是没有区别的 ，内部有一个计数变量</p>
<p>对于innodb的话，count（*） 真的会傻不拉几的一行一行的数，效率极低</p>
<p>一般聚合函数不单独使用，要配合分组一起用。这样意义更大</p>
<p>严格的讲，以group by a，b，c为例，则select的列，只能在a，b，c里选择，语义上才没有矛盾</p>
<p><img src="http://ww1.sinaimg.cn/large/9c52df3dgy1gaqlzk6hf2j20dg0960ve.jpg" alt="image-20200109074542203"></p>
<p>先计算所有人的平均分。</p>
<p>select avg(score) ,name from result group by(name)</p>
<p><img src="http://ww1.sinaimg.cn/large/9c52df3dgy1gaqlzz8aiwj20i806qaci.jpg" alt="image-20200109080311830"></p>
<p><img src="http://ww1.sinaimg.cn/large/9c52df3dgy1gaqm0d44nbj20jw0a9gq6.jpg" alt="image-20200109080604644"></p>
<p>用score进行逻辑运算，挂科的标记成1，没有挂科的标记成0</p>
<p>挂科数就是g的sum结果</p>
<p>综合上面的两个sql语句</p>
<p><img src="http://ww1.sinaimg.cn/large/9c52df3dgy1gaqm0v7o7xj20h507tq5k.jpg" alt="image-20200109081022282"></p>
<p><img src="http://ww1.sinaimg.cn/large/9c52df3dgy1gaqm15ebucj20ih06q41h.jpg" alt="image-20200109081143171"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/09/SQL%E7%BB%83%E4%B9%A0/" data-id="ckn4703vu000a0svh7pjrb67c" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-一致性哈希" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/" class="article-date">
  <time class="dt-published" datetime="2020-01-09T12:20:10.000Z" itemprop="datePublished">2020-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/">一致性哈希</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>经典的服务器如何抗压？</p>
<img src="http://ww1.sinaimg.cn/large/9c52df3dgy1gaqlxw4fc6j20i30m6jw9.jpg" alt="image-20200109202950349" style="zoom:33%;" />

<p>前端无差别接受request</p>
<p>我想把“左” 31 存到这个服务里。</p>
<p>前端的request带相同的hash函数</p>
<p>“左” 经过hash函数再取模3后会得到0,1,2中一个值</p>
<p>如果是1 ，就把这个值存在1 这个机器上</p>
<p>“yao”进hash函数取模3后还会得到0,1,2 中的一个值，</p>
<p>可能是0 ，然后放到 后端的0 这号机器上</p>
<p>因为我不同的String ，经过hash函数算完后，均匀的得到0,1,2上面的一个，</p>
<p>所以 0 ，1， 2 这三台机器负载都均衡</p>
<p>那我在查得过程中怎么查呢？</p>
<p>我想查“左” 的value 是多少，到了前端，我还是用“左”进入hash函数 ，取模得到哪一个服务器</p>
<p>就会去1 这台机器上去拿“左”向对应的年龄是多少。</p>
<p>返回给前端，返回给用户</p>
<p>这就是经典的 服务器的抗压结构</p>
<hr>
<p>但是 当我 需要加机器或者减机器的时候，这个结构就不行了。</p>
<p>就跟hash表扩容一样，原来取模的是3，现在要取模100</p>
<p>所有的数据归属全变了，原来放在1 机器上，接下来放到哪里呢？</p>
<p>必须要把“左”用hash函数取模100然后知道该往那一台机器上迁移</p>
<p>这样代价很高</p>
<p>你就不得不把所有的 数据拿出来，重新计算一遍。然后在扔到扩完之后的机器上。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/" data-id="ckn4703w4000s0svhh9yu6g6w" data-title="一致性哈希" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%93%88%E5%B8%8C/" rel="tag">哈希</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java%E5%9F%BA%E7%A1%80/">java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS/" rel="tag">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BST/" rel="tag">BST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jpa/" rel="tag">jpa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%B2%BB%E6%B3%95/" rel="tag">分治法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/" rel="tag">单向链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%88%E5%B8%8C/" rel="tag">哈希</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" rel="tag">哈希表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%96%87/" rel="tag">回文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE/" rel="tag">图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/" rel="tag">堆排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">完全二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" rel="tag">布隆过滤器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">平衡二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" rel="tag">序列化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" rel="tag">归并排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E6%93%82%E5%8F%B0/" rel="tag">打擂台</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" rel="tag">时间复杂度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88%E8%B7%AF%E5%BE%84/" rel="tag">栈路径</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/" rel="tag">桶排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A9%E9%98%B5/" rel="tag">矩阵</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A1%A8%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/" rel="tag">表单向链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE/" rel="tag">链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BFS/" style="font-size: 16px;">BFS</a> <a href="/tags/BST/" style="font-size: 10px;">BST</a> <a href="/tags/DFS/" style="font-size: 14px;">DFS</a> <a href="/tags/c/" style="font-size: 10px;">c#</a> <a href="/tags/jpa/" style="font-size: 10px;">jpa</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 20px;">二叉树</a> <a href="/tags/%E5%88%86%E6%B2%BB%E6%B3%95/" style="font-size: 18px;">分治法</a> <a href="/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">单向链表</a> <a href="/tags/%E5%93%88%E5%B8%8C/" style="font-size: 10px;">哈希</a> <a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" style="font-size: 14px;">哈希表</a> <a href="/tags/%E5%9B%9E%E6%96%87/" style="font-size: 10px;">回文</a> <a href="/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">堆排序</a> <a href="/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 12px;">完全二叉树</a> <a href="/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" style="font-size: 10px;">布隆过滤器</a> <a href="/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">平衡二叉树</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 10px;">并查集</a> <a href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 10px;">序列化</a> <a href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" style="font-size: 12px;">归并排序</a> <a href="/tags/%E6%89%93%E6%93%82%E5%8F%B0/" style="font-size: 12px;">打擂台</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 14px;">排序</a> <a href="/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" style="font-size: 10px;">时间复杂度</a> <a href="/tags/%E6%A0%88/" style="font-size: 14px;">栈</a> <a href="/tags/%E6%A0%88%E8%B7%AF%E5%BE%84/" style="font-size: 10px;">栈路径</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 14px;">框架</a> <a href="/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">桶排序</a> <a href="/tags/%E7%9F%A9%E9%98%B5/" style="font-size: 16px;">矩阵</a> <a href="/tags/%E8%A1%A8%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">表单向链表</a> <a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 10px;">贪心</a> <a href="/tags/%E9%93%BE/" style="font-size: 10px;">链</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 14px;">链表</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 12px;">队列</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 16px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/05/hex/">hex</a>
          </li>
        
          <li>
            <a href="/2020/05/24/springDataJPA/">springDataJPA</a>
          </li>
        
          <li>
            <a href="/2020/04/27/%E5%AE%9A%E4%BD%8D/">contextmenustrip 定位</a>
          </li>
        
          <li>
            <a href="/2020/04/26/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E8%A1%A8%E5%A4%B4/">判断是否是表头</a>
          </li>
        
          <li>
            <a href="/2020/04/26/%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E6%A1%86%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6/">设置文本框的最大长度</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>